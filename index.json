[{"categories":null,"contents":"Today I\u0026rsquo;ve read a post from the code miner blog talking about CSS specificity. CSS Selector Specificity It\u0026rsquo;s a way of avoiding the use of !import directive and it\u0026rsquo;s quite simple:\nSuppose that you have a CSS like this:\n1 2 3 4 5 6 7 8 9 10 11  div { background-color: white; } #box { background-color: red; } .box { background-color: black; }   and this css code is applied to a HTML like this:\n1  \u0026lt;div id=\u0026#34;box\u0026#34; class=\u0026#34;.box\u0026#34;\u0026gt;      The question is: \u0026ldquo;What will be the background color of that div?  The answer is the result of specificity calculation and it\u0026rsquo;s like this:\n   !important style attributes id Class, Attribute selector, pseudo-classes Tag, pseudo-elements     !import  #id .class,[type=\u0026ldquo;input\u0026rdquo;],:hover h1, ::before    The table of points will be:\n   selector !important style attributes id Class, Attribute selector, pseudo-classes Type, pseudo-elements     div 0 0 0 0 1   #box 0 0 1 0 0   .box 0 0 0 1 0    The biggest value we got is #box, which is 00100. And the background color will be red!\nMore examples can be found on the original post: https://blog.codeminer42.com/codetips2-how-specificity-works-in-css/\n","date":"Mar 30","permalink":"https://1pedro.github.io/blog/today-i-learned/til_css_specificity/","tags":["css"],"title":"TIL: CSS Selector Specificity"},{"categories":null,"contents":"Today I was exercising some competitive programming problems using Codility. The first problem named \u0026ldquo;Binary Gap\u0026rdquo; consists in a way to determine the longest zero occurrences in a binary string. The problem gives us a number and we should convert that number to a binary string then find the biggest consecutive zero occurrences in that binary string.\nThis problem is classified as easy and I didn\u0026rsquo;t take too much time to solve it. But trying to solve this problem lead me to a search about how was the \u0026ldquo;best\u0026rdquo; or \u0026ldquo;correct\u0026rdquo; way to convert an integer into a binary string in Javascript.\nSearching through stack overflow the first answer was great! I just need to do Number(32).toString(2) with 32 being the input number that the problem gives to me. And it\u0026rsquo;s done. With some logic, the problem was solved and I received 100% of Correctness.\nAfter solving the problem a couple of questions came to my mind:\n Is there another way to convert that is more efficient or more performatic? What if I have to make this same conversion but in another programming language?  Again these questions lead me to another search. But now, about how many ways I can convert a number to a binary string.\n   Divsion by 2  The search gave to me two different ways. The first uses a loop that get the rest of the division by 2, store the value in a stack then get the values from the stack concatenating one by one. For learning purpose, I read the specification of the algorithm and make a version. This algorithm looks like this:\n1 2 3 4 5 6 7 8 9 10  function divBy2(number){ let binString = \u0026#39;\u0026#39; while (number \u0026gt;= 1) { binString += number % 2 === 0 ? \u0026#39;0\u0026#39;:\u0026#39;1\u0026#39; number = Math.floor(number /2) } return binString.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) }   This is what I was looking in the first question, but again it\u0026rsquo;s a Javascript way. The methods Math.floor, split, reverse and join will make no sense if I try to put this code in another language. Even for a C-like language.\n   Bit-shift + Bitwise way  The second search result was a bitwise + bit-shift operation. It consists in looping the number 32 times (for 32 bits) walking from the most significant bit to the least significant bit and writing to a string. Again I read the specification and made my own version. It looks like this:\n1 2 3 4 5 6 7 8 9 10  function bitwiseIntToBinaryString(number) { let binString = \u0026#39;\u0026#39; for (let i = 31; i \u0026gt;= 0; i--) { const result = number \u0026gt;\u0026gt; i; binString += result \u0026amp; 1 ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39; } return binString }   With this, I can run this code in almost any C-like language and is way more performatic. The biggest con with this approach is that the number should fit the loop. Converting a 64 bit integer with this approach will lead to bugs. Besides that this algorithm always returns a 32 bit string, which means that even a number like 100 will lead us to 00000000000000000000000001100100 instead of 1100100.\nWith this in mind, I came up with a decision to remove the leading zeros of the string using a regex.\nIn another time I will try to fix the number fit as well. But by now the function without leading zeros is like this:\n1 2 3 4 5 6 7 8 9 10 11  function bitwiseIntToBinaryString(number) { let binString = \u0026#39;\u0026#39; for (let i = 31; i \u0026gt;= 0; i--) { const result = number \u0026gt;\u0026gt; i; binString += result \u0026amp; 1 ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39; } --- return binString +++ return binString.replace(/^0+/, \u0026#39;\u0026#39;) }   With this minor change we have now locked to javascript again but is easy to replace only this line to deal with a regex in another programming language. No logic change is necessary.\n   Conclusion  A simple codility problem gave me the ability to learn and implement two algorithms that are much more performatic and reusable than the language way.\n","date":"Mar 28","permalink":"https://1pedro.github.io/blog/today-i-learned/til_how_to_convert_int_to_binary_using_bitwise_and_bit_shift/","tags":["js","algorithms"],"title":"TIL: How to convert a integer (32 bit) to binary using bitwise and bit-shift"},{"categories":null,"contents":"Iâ€™d never thought about that until faced this problem. For me, git was the best option to keep track of file differences, either a text file or a binary file.\n   The Problem  Today I\u0026rsquo;m facing a problem: I\u0026rsquo;ve tried to add PSD files to a git repository. That\u0026rsquo;s is not \u0026ldquo;wrong\u0026rdquo; but is a big mistake. If the PSD files are changed often you will end up with a large git repository. With it, every time someone tries to pull your updates in a PSD file they have to download the entire file.\n   Example  Suppose that you have a PSD file that is 200MB large. With 3 changes you will have a repository that is 600MB large :0. This is because git cannot make delta from binary files.\nGit uses Delta Encoding. With makes, a commit doesn\u0026rsquo;t store all the files that were changed. Instead, they store the patch of the changes. With PSD files or any other binary files, git cannot make a patch, because every change in a binary file also changes all file structures. (In truth git can make a patch but the size of the patch is the same of the original file)\n   Conclusion  Git has a plugin named git-lfs to help in cases like this. Again git help but not resolve. Git was not made for this use case. No code version system was made for this. Try to use shared storage and make sure that no one is editing the same files at a time.\n","date":"Mar 27","permalink":"https://1pedro.github.io/blog/today-i-learned/git_is_not_suitable_for_binary_large_files/","tags":["git"],"title":"TIL: Git is not suitable for binary large files"},{"categories":null,"contents":"","date":"May 28","permalink":"https://1pedro.github.io/blog/archives/","tags":null,"title":""},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://1pedro.github.io/blog/articles/","tags":null,"title":"Articles"}]